# TypeScriptとは

TypeScriptとはJavaScriptのスーパーセットで最終的にはJavaScriptにトランスパイルされます。

TypeScriptで書かれた型定義ファイルや型情報などはJavaScriptへトランスパイルされるとき、削除されます。TypeScriptの型定義はあくまでJavaScriptを実装する上でのヘルパーとしての役割と考えてください。

TypeScriptの解説は本研修の本懐ではないので、詳しくは解説はしません。

## TypeScriptのハンズオン

TypeScriptのハンズオンはルートディレクトリに配置してあります`ts`で作業ができます。

vscodeでtsフォルダを開き`npm install`で必要なモジュールをインストールしてください。

また、インストールするパッケージの中には`ts-node`というパッケージがあります。`ts-node`はトランスパイル無しでnodeでtsを実行できます。

コードを試したい場合は

```bash
npx ts-node src/{実行したいファイル名}
```

で実行できます。

## JavaScriptの意味不明な挙動

JavaScriptの意味不明な挙動を挙げれば枚挙にいとまがありません。

```js
[] + []; // → ""
{} + []; // → 0
[] + {}; // → "[object Object]"
{} + {}; // → ブラウザによってNaN,または[object Object][object Object]
function add(a,b) {
  return
    a + b; // → undefined
}
```

こういった意味不明な挙動から身を守り、型安全に開発を進めることがTypeScriptを利用する最大の理由の一つです。

### ハンズオン

`[] + []`や`{} + []`などを変数で宣言し、実際にエラーが発生する様子を確認しましょう。

## TypeScriptの型推論

TypeScriptでは暗黙的な型推論と明示的な型推論があります。

### 暗黙的な型推論

コーディングの生産性に対する影響を小さく抑えながら型の安全性を提供するために可能な限り型推論します。

```ts
var foo = 123;
foo = '456'; // error: `string`を`number`に代入できません。
```

このようなコードの場合、一度`foo`にnumber型が代入されたことから、TypeScriptは`foo`をnumber型と判断し、２行目のstring型の代入にエラーを表示します。

### 明示的な型推論

暗黙的な型推論が正確でない場合、明示的にコード上に型を指定する(型アノテーションを書く)ことができます。型アノテーションを書くメリットは以下です。

1. コンパイラの理解を助けるだけでなく、次にそのコードを見る開発者にとってのドキュメントになります。
2. コンパイラがどのようにコードを理解するか、ということを強制します。つまり、コードに対する開発者の理解を、コンパイルの方チェックアルゴリズムに反映させるということです。

TypeScriptではアノテーションを末尾につけます。対象の後ろにコロンを付けて型を指定します。

```ts
var foo: number = 100
```

型が一致し兄場合、エディター上にエラーを表示します。

```ts
var foo: number = '123' // エラー: `string`を`number`に代入できません
```

### ハンズオン

string型の変数を宣言し、他の型の値を再代入しようとし、エラーが表示されることを確認してみましょう。

### 構造的な型

TypeScriptでは、開発者の型定義に関する負担をへらすため構造的な型を採用しています。

```ts
type Model2D = {
  x: number
  y: number
}
type Model3D = {
  x: number
  y: number
  z: number
}

function drawPoint(arg: Model2D) {
  // 実装
}

const model2d: Model2D = {
  x: 100,
  y: 100
}
const model3d: Model3D = {
  x: 100,
  y: 100,
  z: 100
}
drawPoint(model2d) // OK!
drawPoint(model3d) // こちらもOK!
```

2Dモデルの型定義が、`x`,`y`の2つのnumber型の数値を持つのに対し、3Dモデルが加えて`z`をnumber型で持つように型定義しました。

関数`drawPoint`は2Dモデル型を引数で受け取れるように定義しましたが、3Dモデルも引数で問題なく受け取れます。

これは、あくまで`drawPoint`が`x`,`y`が定義されていれば他に関しては関与していないことを示しています。

構造的な型定義を活かすためには、関数で受け取る引数の型は関数で使うもの以外要求しないことが重要です。不要なプロパティがたくさん用意されているインターフェースやtypeを引数にしてしまいますと、使い勝手が悪くなります。

### ハンズオン

`{ userId: number }`のプロパティを含んだ型を引数とするユーザーIDを表示する関数と、`{ userId: number }`を含んだユーザーの型を作成し、構造的な型が機能していることを確認してください。
